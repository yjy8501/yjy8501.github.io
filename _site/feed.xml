<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-30T04:12:11+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Rakugaki</title><subtitle>개발 낙서장 &amp; 일상</subtitle><author><name>양재용</name><email>yjy850146@gmail.com</email></author><entry><title type="html">Docker 빠른 실전편</title><link href="http://localhost:4000/Docker/" rel="alternate" type="text/html" title="Docker 빠른 실전편" /><published>2023-09-30T00:00:00+09:00</published><updated>2023-09-30T00:00:00+09:00</updated><id>http://localhost:4000/Docker</id><content type="html" xml:base="http://localhost:4000/Docker/"><![CDATA[<p><br /></p>

<h1 id="docker실압편">Docker(실압편)</h1>

<h2 id="docker란">Docker란?</h2>

<ul>
  <li>도커는 애플리케이션과 그 실행 환경을 격리된 컨테이너로 패키징하고,
이러한 컨테이너를 사용하여 실행 환경을 가상화하는 기술이다.</li>
</ul>

<hr />

<h2 id="docker-설치-방법">Docker 설치 방법</h2>

<ul>
  <li><a href="https://docs.docker.com/desktop/install/windows-install/"><strong>윈도우용 docker 설치</strong></a></li>
  <li><a href="https://docs.docker.com/desktop/install/mac-install/"><strong>맥북용 docker 설치</strong></a></li>
  <li>[<strong>Ubuntu용 docker 설치](https://docs.docker.com/engine/install/ubuntu/)  →</strong> 서버에도 docker를 설치해야함으로 필수적으로 알아야한다.</li>
</ul>

<hr />

<h2 id="docker-용어">Docker 용어</h2>

<ul>
  <li>이미지
    <ul>
      <li>도커 이미지(Docker Image)는 도커 컨테이너를 생성하기 위한 템플릿.</li>
      <li>컨테이너를 생성하기에 필요한 설계도라고 생각하면 된다.</li>
    </ul>
  </li>
  <li>컨테이너
    <ul>
      <li>우리가 생각하는 그 컨테이너가 맞다(항구에서 짐이 적재되어 있는)
  → <strong>소프트웨어 수송, 즉 배포</strong></li>
      <li>도커 컨테이너(Docker Container)는 도커 이미지를 바탕으로 생성된
  가볍고 독립적인 실행 단위</li>
    </ul>
  </li>
  <li>빌드
    <ul>
      <li>도커 이미지를 생성하는 과정</li>
    </ul>
  </li>
  <li>도커 허브
    <ul>
      <li>도커 이미지를 저장하는 저장소(Github와 유사)</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="docker-사용법">Docker 사용법</h2>

<h3 id="docker-저장소-가입">Docker 저장소 가입</h3>

<ol>
  <li><a href="https://hub.docker.com/">https://hub.docker.com/</a> 에 접속 후 회원가입</li>
  <li>도커 허브에 로그인 하기</li>
</ol>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker login
</code></pre></div></div>

<ol>
  <li>도커 허브 메뉴의 Repositories로 이동한 후 우측 상단의 “Create Repository” 버튼을 클릭한다.</li>
  <li>“Repository Name”에 저장소 이름을 입력한다.(다른 사용자가 사용중인 이름X)</li>
  <li>“Visibility”에서 “Public”을 선택.</li>
  <li>“Create” 버튼을 클릭.</li>
</ol>

<h3 id="docker-빌드">Docker 빌드</h3>

<ul>
  <li>원하는 Spring 프로젝트에 들어가서, Gradle창 → bootJar를 실행해준다
    <ul>
      <li>build도 가능하나, 불필요한 파일이 생성된다</li>
      <li>build/libs 하단에 jar 파일이 생성된 것을 확인할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p>프로젝트 최상단 디렉토리에 Dockerfile 작성하기</p>

    <div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># openjdk11를 베이스로 이미지를 생성한다.</span>
  FROM openjdk:11
  <span class="c"># JAR_FILE에 jar 빌드 파일이 있는 경로를 저장한다</span>
  ARG JAR_FILE=build/libs/*.jar
  <span class="c"># jar 빌드 파일을 도커 컨테이너 안 app.jar 이름으로 복사</span>
  COPY ${JAR_FILE} app.jar
  <span class="c"># 컨테이너가 실행 될 때 실행되는 명령어</span>
  <span class="c"># 컨테이너가 실행되면 jar 파일을 실행한다.</span>
  ENTRYPOINT ["java","-jar","/app.jar"]
</code></pre></div>    </div>
  </li>
  <li>
    <p>docker 빌드하기</p>

    <div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  docker build -t {username}/{repository}:tag . 
</code></pre></div>    </div>

    <ul>
      <li>username은 도커 허브 사용자 ID</li>
      <li>repository는 도커 허브 레포지토리 이름</li>
      <li>tag는 버전 적어주면 된다.(ex 0.1)</li>
      <li>tag 뒤에  <strong>.</strong>  는 현재 디렉토리를 나타낸다(빼먹지 말고, 경로 설정에 활용하도록 하자).</li>
    </ul>
  </li>
  <li>
    <p>docker 푸쉬하기(이미지를 도커 허브 레포지토리로 푸쉬)</p>

    <div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  docker push {username}/{repository}:tag
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="docker-컨테이너">Docker 컨테이너</h3>

<ul>
  <li>
    <p>저장소에서 이미지 받아오기</p>

    <div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  docker pull {username}/{repository}:tag
</code></pre></div>    </div>
  </li>
  <li>
    <p>이미지를 컨테이너로 실행</p>

    <div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  docker run -p 8080:8080 --name {컨테이너 이름} {username}/{repository}:tag
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="유용한-docker-명령어">유용한 Docker 명령어</h3>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 만들어진 컨테이너 실행
docker start [컨테이너 이름 또는 ID]

// 실행중인 컨테이너 중지
docker stop [컨테이너 이름 또는 ID]

// 실행중인 컨테이너 확인
docker ps -a -&gt;(-a 제거시 모든 컨테이너 목록 확인 가능)

// 컨테이너 제거
docker rm [컨테이너 이름 또는 ID]

// 이미지 목록 조회
docker images 

// 이미지 제거
docker rmi [이미지 이름 또는 ID]
</code></pre></div></div>

<h3 id="advanced">Advanced</h3>

<ul>
  <li>Docker-compose</li>
  <li>Docker-buildx</li>
  <li>쿠버네티스</li>
</ul>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">그래프 탐색 알고리즘</title><link href="http://localhost:4000/memoir/SEB_BE15/" rel="alternate" type="text/html" title="그래프 탐색 알고리즘" /><published>2023-05-16T00:00:00+09:00</published><updated>2023-05-16T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE15</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE15/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="-너비-우선-탐색bfs-breadth-first-search"><font color="#A0D7EF"> 너비 우선 탐색(BFS, Breadth First Search)</font></h2>
<blockquote>
  <p>인접한 정점부터 방문하는 탐색 방식</p>
</blockquote>

<h3 id="-너비-우선-탐색의-특징"><font color="#A0D7EF"> 너비 우선 탐색의 특징</font></h3>
<hr />

<ul>
  <li>최단 경로 탐색에 유리하다(같은 거리에 있는 정점들을 먼저 방문한다)</li>
  <li>방문한 정점들을 저장해야 하는 경우 메모리 사용이 크다</li>
  <li>그래프의 크기와 밀도가 크면 BFS의 성능이 저하된다</li>
  <li>시작 정점에서 도착할 수 없는 정점에 대해서는 탐색하지 않는다</li>
  <li>방문 여부를 체크하는 자료구조를 사용해야한다(무한 루프 방지)</li>
</ul>

<h3 id="-구현-방법"><font color="#A0D7EF"> 구현 방법</font></h3>
<hr />

<ol>
  <li>큐 자료구조를 활용해 구현된다</li>
  <li>시작 노드를 큐에 삽인한 후, 큐가 빌 때까지 반복한다</li>
  <li>큐에서 현재 정점을 가져온다</li>
  <li>현재 정점은 이미 방문했다고 체크한다</li>
  <li>현재 정점에 인접한 정점을 모두 큐에 삽입힌다</li>
  <li>큐가 빌 때까지 반복한다</li>
</ol>

<h3 id="-bfs를-활용해야-하는-경우"><font color="#A0D7EF"> BFS를 활용해야 하는 경우</font></h3>
<hr />

<ol>
  <li>최단 거리를 구해야 하는 문제</li>
  <li>검색 대상의 규모가 크지 않고, 시작 정점으로 부터 멀지 않을 경우
    <blockquote>
      <p>한 경로가 무한히 이어진다 해도, 모든 경로를 확인하기에 반드시 
 최단 경로를 찾을 수 있다</p>
    </blockquote>
  </li>
</ol>

<h3 id="-bfs-활용-시-주의-할-점"><font color="#A0D7EF"> BFS 활용 시 주의 할 점</font></h3>
<hr />

<ol>
  <li>방문 여부 체크</li>
  <li>큐의 활용</li>
  <li>최단 경로 탐색</li>
  <li>메모리 공간(메모리를 많이 사용한다)</li>
</ol>

<h3 id="-bfs-예시-구현"><font color="#A0D7EF"> BFS 예시 구현</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">bfs_array</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">src</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">//bfs의 경우 큐를 사용합니다.</span>
	    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
			<span class="c1">//시작 지점을 큐에 넣어주고, 해당 버택스의 방문 여부를 변경합니다.</span>
	    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>
	    <span class="n">visited</span><span class="o">[</span><span class="n">src</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
			<span class="c1">//큐에 더이상 방문할 요소가 없을 경우까지 반복합니다.</span>
	    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
				<span class="c1">//현재 위치를 큐에서 꺼낸 후</span>
	      <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
				<span class="c1">// 현재 방문한 정점을 result에 삽입합니다.</span>
				<span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cur</span><span class="o">);</span>
				<span class="c1">//전체 배열에서 현재 버택스의 행만 확인합니다.</span>
	      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">[</span><span class="n">cur</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
					<span class="c1">//길이 존재하고, 아직 방문하지 않았을 경우</span>
	        <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">cur</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
						<span class="c1">//큐에 해당 버택스의 위치를 넣어준 이후</span>
	          <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
						<span class="c1">//방문 여부를 체크합니다.</span>
	          <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
	        <span class="o">}</span>
	      <span class="o">}</span>
	    <span class="o">}</span>
			<span class="c1">//이어진 모든 길을 순회한 후 방문 여부가 담긴 ArrayList를 반환합니다.</span>
	    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>

</code></pre></div></div>

<p><br /></p>

<h2 id="-깊이-우선-탐색dfs-depth-first-search"><font color="#A0D7EF"> 깊이 우선 탐색(DFS, Depth First Search)</font></h2>
<blockquote>
  <p>시작 정점에서 최대한 깊숙이 탐색하고, 다음 분기로 탐색을 진행하는 탐색 방식</p>
</blockquote>

<h3 id="-깊이-우선-탐색의-특징"><font color="#A0D7EF"> 깊이 우선 탐색의 특징</font></h3>
<hr />

<ul>
  <li>한 분기를 완벽하게 탐색한 후, 다음 분기로 넘어간다</li>
  <li>더 이상 탐색이 불가능한 상태가 되면 이전 분기로 돌아와 다음 분기를 탐색한다</li>
  <li>그래프 내 순환구조(Cycle)를 고려하여 방문한 정점은 다시 방문하지 않도록 한다</li>
</ul>

<h3 id="-구현-방법-1"><font color="#A0D7EF"> 구현 방법</font></h3>
<hr />

<ol>
  <li>스택이나 재귀를 통해 구현한다(재귀 구현 권장)</li>
  <li>방문했던 정점인지 확인한다. 방문 했다면 재귀 호출을 종료한다</li>
  <li>방문하지 않았다면, 방문 여부를 체크한다</li>
  <li>해당 정점에 연결된 모든 정점을 재귀호출로 순회한다</li>
</ol>

<h3 id="-dfs를-활용해야-하는-경우"><font color="#A0D7EF"> DFS를 활용해야 하는 경우</font></h3>
<hr />

<ol>
  <li>경로의 특징을 저장해야 하는 문제(탐색중에 조건이 요구되는 경우)</li>
  <li>자동 미로 생겅 같은 문제(하나의 경로만 구할 수 있다)</li>
  <li>검색 대상 그래프가 정말 클 때(BFS에 비해 메모리를 적게 사용한다)</li>
</ol>

<h3 id="-dfs-활용-시-주의할-점"><font color="#A0D7EF"> DFS 활용 시 주의할 점</font></h3>
<hr />

<ol>
  <li>순환구조를 고려하여 방문한 정점은 다시 방문하지 말아야한다</li>
  <li>최단 경로를 보장 할 수 없다</li>
</ol>

<h3 id="-dfs-예시-구현"><font color="#A0D7EF"> DFS 예시 구현</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">src</span><span class="o">,</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// 이미 방문했다면</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">src</span><span class="o">]</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">src</span><span class="o">);</span>    <span class="c1">// 방문한 정점을 저장</span>
					<span class="k">return</span> <span class="n">result</span><span class="o">;</span>      <span class="c1">// 저장한 데이터를 반환하며, 재귀호출을 종료</span>
				<span class="o">}</span>

				<span class="c1">// 아직 방문하지 않았다면</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">src</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>           <span class="c1">// 방문한 정점을 표기</span>
        
				<span class="c1">// 현재 정점에서 이동할 수 있는 정점을 순회하며 재귀 호출</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">src</span><span class="o">][</span><span class="n">index</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
								<span class="c1">// 재귀 호출을 통해, 방문 여부를 담은 데이터를 반환과 동시에 할당</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
				<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

</code></pre></div></div>

<p><br /></p>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>오늘은 그래프에 대해 공부했다!<br />
1년 6개월 만에 다시 그래프를 공부하니까 역시 쉽지 않다는 생각이 들었다.</p>

<p>일차원 배열 형식의 구조에 익숙해서 그런지<br />
이차원 배열 형식의 문제를 풀 때 자주 뇌정지가 온다,,<br />
그리고 아직 재귀적 사고도 익숙하지 않아서 흐름을 잡는게 쉽지 않은 것 같다</p>

<p>하지만 내가 아직 이차원 배열, 재귀, 그래프에 관한 사고방식이 미숙하기 때문이라고 생각하고,<br />
계속 풀다보면 어느 순간부터 흐름을 잡을 수 있다고 믿고 있다!!</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><category term="Algorithm" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">재귀</title><link href="http://localhost:4000/memoir/SEB_BE14/" rel="alternate" type="text/html" title="재귀" /><published>2023-05-10T00:00:00+09:00</published><updated>2023-05-10T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE14</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE14/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="-재귀recursion"><font color="#A0D7EF"> 재귀(Recursion)</font></h2>

<blockquote>
  <p>원래의 자리로 되돌아가거나 되돌아옴.<br />
함수 내부에 자기 자신을 호출하는 메소드</p>
</blockquote>

<h3 id="--재귀-함수의-장점"><font color="#A0D7EF">  재귀 함수의 장점</font></h3>
<hr />

<ul>
  <li>불필요하게 여러 개의 반복문을 사용하지 않아 코드가 간결하다</li>
  <li>변수를 여러개 사용 할 필요가 없다</li>
</ul>

<h3 id="-재귀-함수의-단점"><font color="#A0D7EF"> 재귀 함수의 단점</font></h3>
<hr />

<ul>
  <li>반복문과 달리 코드의 흐름을 직관적으로 파악하기 어렵다.</li>
  <li>반복하여 메소드를 호출하면 변수, 반환값이 스텍 영역에 저장되어<br />과도하게 호출하게 되면 메모리를 더 많이 사용하게 된다</li>
  <li>메소드를 종료할 때 복귀를 위한 컨텍스트 스위칭 비용이 발생한다</li>
</ul>

<h3 id="-재귀-함수를-사용하기-위한-조건"><font color="#A0D7EF"> 재귀 함수를 사용하기 위한 조건</font></h3>
<hr />

<p>문제를 작은 단위로 쪼갤 수 있어야 한다 -&gt; recursion case<br />
재귀 호출이 종료되는 시점이 있어야 한다 -&gt; base case</p>

<h3 id="-재귀적으로-사고-하는-방법"><font color="#A0D7EF"> 재귀적으로 사고 하는 방법</font></h3>
<hr />

<ol>
  <li>재귀 함수의 입력값과 출력값 정의하기</li>
  <li>문제를 쪼개고 경우의 수를 나누기</li>
  <li>단순한 문제 해결하기</li>
  <li>복잡한 문제 해결하기</li>
  <li>코드로 구현하기</li>
</ol>

<h2 id="-실습"><font color="#A0D7EF"> 실습</font></h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">Recursion</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ColorPaper</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">blue</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">white</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">board</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span>  <span class="kt">void</span> <span class="nf">paper</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 체크가 트루일 때</span>
        <span class="k">if</span><span class="o">(</span><span class="n">check</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">size</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 첫번째 요소가 0 일 때</span>
            <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">white</span><span class="o">++;</span>
            <span class="c1">// 두번째 요소가 1 일 때</span>
            <span class="k">else</span>
                <span class="n">blue</span><span class="o">++;</span>

            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 사이즈를 나눈다</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// 좌상단</span>
        <span class="n">paper</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="c1">// 우상단</span>
        <span class="n">paper</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">size</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="c1">// 좌하단</span>
        <span class="n">paper</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">size</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="c1">// 우하단</span>
        <span class="n">paper</span><span class="o">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">size</span><span class="o">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">size</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span> <span class="o">+</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col</span> <span class="o">+</span> <span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">!=</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">bf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="c1">// 이차원 배열을 입력 받는다</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// parper함수에 넣는다</span>
        <span class="n">paper</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">white</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">blue</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>

<p><a href="https://www.acmicpc.net/problem/2630">백준_색종이 만들기</a></p>

<p><br /></p>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>그동안 알고리즘이나 코테를 풀 때 수도 코드를 생략하고 작성했었다.<br />
수도 코드를 작성 하는 편이 실수도 덜 나고 코드 짜기 쉽긴 했지만<br />
귀찮다는 이유 하나로 소외했었었다.<br /><br />
재귀 알고리즘을 공부하면서 머리 속으로만 생각해서 코드를 짜면<br />
앞에 내용과 뒤의 내용이 헷갈리기 시작해서 코드가 꼬이기 시작했다.<br /><br />
요즘 백준 실버 상위, 골드 하위 문제를 풀면서 위의 문제가 많아지기 시작했는데<br />
오늘 수도 코드를 이용해서 푼 문제가 한번만에 통과하는 것을 보고<br />
수도 코드의 작성의 중요성을 알게 되었고<br />
재귀도 멀리 보면 어렵지만 하나하나 차근차근 풀어보면<br />
충분히 풀 수 있다는 자신감이 들었다.<br /><br />
재귀 어려운 내용이지만 꼭 익숙해저셔 자신 있게 풀 수 있는 날이 왔으면 좋겠다</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><category term="Algorithm" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">객체 지향 심화</title><link href="http://localhost:4000/memoir/SEB_BE13/" rel="alternate" type="text/html" title="객체 지향 심화" /><published>2023-04-30T00:00:00+09:00</published><updated>2023-04-30T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE13</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE13/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="-객체지향-4원칙"><font color="#A0D7EF"> 객체지향 4원칙</font></h2>

<ul>
  <li>추상화
    <ul>
      <li>사물의 성질, 공통성을 추출하여 파악하는 것</li>
      <li>클래스의 공통적인 요소들을 봅아서 상위 클래스를 만들어 내는 것</li>
      <li>인터페이스, 추상 클래스가 있다.</li>
      <li>인터페이스는 추상 메소드를 묶어 놓은 것, 추상 클래스는 필드, 메소드를 모두 가지면서 추상 클래스를 가진다</li>
      <li>추상 클래스는 하위 클래스에서 인스턴스화 할 수 있다</li>
      <li><code class="language-plaintext highlighter-rouge">Animal animal = new Cat();</code> <br />추상클래스 Animal 참조변수는 하위 클래스인 Cat의 인스턴스를 가리킨다</li>
      <li><code class="language-plaintext highlighter-rouge">Shopping shopping = new OnLineShopping();</code><br /> 인터페이스 Shpping 참조변수는 인터페이스를 구현한 OnLineShopping 인스턴스를 가리킨다</li>
    </ul>
  </li>
  <li>상속
    <ul>
      <li>기존에 있는 클래스를 재활용하여 새로운 클래스를 작성하는 방법</li>
      <li>~은 ~이다 관계가 성립해야 한다</li>
    </ul>
  </li>
  <li>다형성
    <ul>
      <li>하나의 객체가 여러 가지 형태를 가질 수 있는 성질</li>
      <li>인터페이스나 추상 클래스를 이용하여 한 타입의 참조 변수에 여러 타입의 객체를 넣을 수 있도록 한다</li>
    </ul>
  </li>
  <li>캡슐화
    <ul>
      <li>특정 객체의 정보를 외부(다른 객체)로 부터 은닉한다</li>
      <li>접근 지정자를 이용해 캡슐화를 할 수 있다</li>
      <li>객체는 다른 객체가 무엇을 실행하는지 알지만 어떻게 수행하는지에 대해 알 수 없어야 한다</li>
    </ul>
  </li>
</ul>

<h2 id="-solid-원칙"><font color="#A0D7EF"> SOLID 원칙</font></h2>

<h3 id="-단일-책임-원칙srp-single-responsibility-principle"><font color="#A0D7EF"> 단일 책임 원칙(SRP, Single Responsibility Principle)</font></h3>
<ul>
  <li>하나의 클래스는 하나의 책임만 가져야 한다.</li>
  <li>주문 클래스는 주문만, 메뉴 클래스는 메뉴에 관련된 책임만 가져야한다.</li>
  <li>개발자라는 클래스에 백엔드, 프론트에 관한 행위를 구현한다 -&gt; 백엔드 클래스, 프론트 클래스로 분리한다</li>
</ul>

<h3 id="-개방-폐쇄-원칙ocp-openclosed-principle"><font color="#A0D7EF"> 개방-폐쇄 원칙(OCP, Open/Closed Principle)</font></h3>
<ul>
  <li>소프트웨어 요소(클래스, 모듈, 함수 등)는 확장에 대해서는 개방되어 있어야 하지만 변경에 대해서는 폐쇄적이어야 한다는 원칙</li>
  <li>추상화, 상속, 인터페이스를 사용하여 확장, 새로운 요소에 유연하게 대응할 수 있다</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalSoundPlayer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">playSound</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<blockquote>
  <p>makeSound()를 추상 메소드로 선언함으로 AnimalSoundPlayer는 새로운 animal 클래스가 추가되더라도 수정 할 필요가 없다</p>
</blockquote>

<h3 id="-리스코프-치환-원칙lsp-liskov-subsitution-principle"><font color="#A0D7EF"> 리스코프 치환 원칙(LSP, Liskov Subsitution Principle)</font></h3>
<ul>
  <li>프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다는 원칙</li>
  <li>상위 클래스의 참조변수에 하위 클래스를 할당하더라도 상위 클래스의 인스턴스 역할을 하는데 문제가 없다</li>
  <li><code class="language-plaintext highlighter-rouge">Daughter daughter = new Father()</code> -&gt; 딸의 클래스는 아버지 클래스를 상속 할 수 없다</li>
  <li><code class="language-plaintext highlighter-rouge">Daughter daughter = new Mother()</code> -&gt; 딸의 클래스는 어머니 클래스를 상속 할 수 있다</li>
</ul>

<h3 id="-인터페이스-분리-원칙isp-interface-segregation-principle"><font color="#A0D7EF"> 인터페이스 분리 원칙(ISP, Interface Segregation Principle)</font></h3>
<ul>
  <li>특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다는 원칙</li>
  <li>인터페이스를 분리하면 결합도를 낮출 수 있다</li>
  <li>인터페이스의 기능이 명확해지고, 대체 가능성이 높아진다</li>
</ul>

<h3 id="-의존관계-역전-원칙dip-dependency-inversion-principle"><font color="#A0D7EF"> 의존관계 역전 원칙(DIP, Dependency Inversion Principle)</font></h3>
<ul>
  <li>추상화에 의존해야지 구체화에 의존하면 안된다는 원칙</li>
  <li>특정 객체가 어떤 객체를 사용할지 결정하면 안된다</li>
  <li>자동차와 타이어의 관계에서 자동차에 특정 타이어를 구현 하는 것 보다 타이어 인터페이스에 의존하고<br />
타이어 인터페이스를 구현한 여러 타이어 클래스를 생성하는 것이 좋다</li>
  <li>구현체에 의존하지 않고, 추상클래스, 인터페이스에 의존해야한다</li>
  <li>DI(Dependency Injection)를 이용해 객체간의 의존관계를 설정한다(생성자를 통해 주입받는다)</li>
</ul>

<p><br /></p>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>정처기 준비하면서 이론으로만 알던 내용들을 실습으로 학습하니까<br />
객체 지향 원칙을 지키면서 코딩하는 것이 쉽지 않다는 것을 느꼈다.</p>

<p>그동안 자바를 사용하면서 이런 것도 지키지 않고 사용했다는 것이 부끄러워졌다.</p>

<p>그동안 내가 생각하고 있던 규칙이 흔들렸고, 3일동안 계속 객체 지향에 대해 고민했다.</p>

<p>아직 완전히 객체 지향을 받아드린 것은 아니지만, 매우 효율적이고 재밌다는 생각이 들었다.</p>

<p>기능을 구현하는 것도 중요하지만 객체 지향에 맞게 리팩토링하는 작업도 중요하다는 생각도 들었다.</p>

<p>객체 지향을 본격적으로 이해하기 시작했으니까 앞으로는 더 좋은 개발자가 될 수 있겠다는 생각이 들었고<br />
내가 이 분야를 어느 정도 정복 했을 때 내가 어떻게 변화되어 있을까 궁금해졌다!</p>

<p>앞으로 더 열심히 해서 좋은 개발자가 되도록 노력하자!! 꾸준히 한다면 시간은 나의 편이다.</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코드스테이츠 백엔드 12일차 회고록</title><link href="http://localhost:4000/memoir/SEB_BE12/" rel="alternate" type="text/html" title="코드스테이츠 백엔드 12일차 회고록" /><published>2023-04-26T00:00:00+09:00</published><updated>2023-04-26T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE12</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE12/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="1-다형성ploymorphism"><font color="#A0D7EF">1. 다형성(Ploymorphism)</font></h2>

<ul>
  <li>하나의 객체가 여러가지 형태를 가질 수 있는 성질</li>
  <li>상위 클래스 타입의 참조변수를 통해 하위 클래스의 객체를 참조할 수 있다</li>
  <li><code class="language-plaintext highlighter-rouge">참조변수.instanceof(타입)</code> 을 통해 캐스팅이 가능한지 여부를<br /> boolean 타입으로 확인 가능하다</li>
  <li>다형성을 잘 활용하면 많은 중복되는 코드를 줄이고 보다 편하게 코드를 작성 할 수 있다</li>
</ul>

<p><br /></p>

<h2 id="-2-추상화abstraction"><font color="#A0D7EF"> 2. 추상화(Abstraction)</font></h2>

<ul>
  <li>사물이나 표상의 어떤 성질, 공통성, 본질을 추출하여 파악하는 것</li>
  <li>기존 클래스들의 공톡적인 요소들을 뽑아서 상위 클래스를 만들어 내는 것</li>
  <li><code class="language-plaintext highlighter-rouge">abstract</code> 키워드를 통해 추상 클래스, 메소드를 정의할 수 있다</li>
  <li>추상 클래스를 상속받을 때 추상 클래스의 추상 메소드를 모두 오버라이딩 해야한다<br />(하지 않을 시 상속 받는 클래스도 추상 클래스가 된다)</li>
  <li>추상 클래스는 인스턴스를 생성 할 수 없다</li>
  <li>상속 계층도 상층부에 위치할수록 추상화의 정도가 높다</li>
  <li>다중 상속 불가능</li>
</ul>

<p><br /></p>

<h2 id="-2-인터페이스interface"><font color="#A0D7EF"> 2. 인터페이스(Interface)</font></h2>

<ul>
  <li>추상 메소드보다 더 높은 추상성을 가진다</li>
  <li>추상 메소드와 상수만을 멤버로 가질 수 있다(default/static 메소드도 생성 가능)</li>
  <li>내부 모든 필드가 <code class="language-plaintext highlighter-rouge">public static final</code>, 메소드가 <code class="language-plaintext highlighter-rouge">public abstract</code> 로 정의된다</li>
  <li><code class="language-plaintext highlighter-rouge">implements</code> 키워드를 통해 인터페이스를 구현 할 수 있다</li>
  <li>인터페이스는 다중 구현을 지원한다</li>
</ul>

<p><br /></p>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>오늘은 다형성과 추상화에 대해 배웠다.</p>

<p>다형성과 추상화 모두 코드의 재사용성과 유지보수에 좋은 역할을 한다</p>

<p>공부하면서 다형성과 추상화를 한번에 생각하여 코드를 짜는 것은 아직 나에게<br />
어렵다는 생각이 들었고, 유지보수, 효율성을 높히기 위해 코드를 고칠 때<br />
클래스들 간에 관계를 정리해가면서는 가능 할 것 같다는 생각이 들었다<br /></p>

<p>빨리 배운 것들을 사용하여 내 것으로 만들고 싶다!!</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코드스테이츠 백엔드 11일차 회고록</title><link href="http://localhost:4000/memoir/SEB_BE11/" rel="alternate" type="text/html" title="코드스테이츠 백엔드 11일차 회고록" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE11</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE11/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="1-상속extends"><font color="#A0D7EF">1. 상속(Extends)</font></h2>

<ul>
  <li>상위 클래스의 기능을 그대로 이어받아 재사용하는 것</li>
  <li>코드의 재사용성을 높이고, 중복을 제거하여 생산성과 유지보수를 높힌다</li>
  <li>보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다</li>
  <li>상속 구조가 복잡해지면 오히려 보수하기 힘들어 질 수 있다</li>
</ul>

<p class="notice--danger">클래스 간의 관계는 <span style="color:#FFFF80"><strong>‘~은 ~이다’</strong></span>(상속관계)  <span style="color:#FFFF80"><strong>‘~은 ~을 가지고 있다’</strong></span>(포함관계)로 확인 할 수 있다.</p>

<h3 id="-매소드-오버라이딩method-overriding"><font color="#A0D7EF"> 매소드 오버라이딩(Method Overriding)</font></h3>
<hr />

<ul>
  <li>상위 클래스로부터 상속받은 매소드와 동일한 이름의 매소드를 재정의하는 것</li>
  <li>상위 클래스의 매소드를 하위 클래스에 맞게 변경하고자 할 때 사용된다</li>
  <li>매소드의 선언부(메소드 이름, 매개 변수, 반환 타입)가 상위 클래스와 완전히 일치해야한다</li>
  <li>접근 제어자의 범위가 상위 클래스의 매소드보다 같거나 넓어야 한다</li>
  <li>예외는 상위 클래스의 매소드보다 많이 선언할 수 없다.</li>
</ul>

<h3 id="-super와-super"><font color="#A0D7EF"> super와 super()</font></h3>
<hr />

<ul>
  <li>super는 상위 클래스의 객체를 가르킨다</li>
  <li>super()는 상위 클래스의 생성자를 호출한다(this()와 사용방법 동일)</li>
</ul>

<h3 id="-object-클래스"><font color="#A0D7EF"> Object 클래스</font></h3>
<hr />

<p align="center"><img src="https://velog.velcdn.com/images/ehgusrlaeh/post/218a70f9-55a0-4ed3-89cd-f374474714b4/image.png" height="250px" width="650px" /></p>

<ul>
  <li>Object 클래스는 자바 클래스 상속계층도에서 최상위에 위치한 클래스이다</li>
  <li>extends를 하지 않으면 자동으로 Object 클래스를 상속한다</li>
  <li>여러가지 유용한 매소드가 있다</li>
</ul>

<h2 id="-2-캡슐화"><font color="#A0D7EF"> 2. 캡슐화</font></h2>

<ul>
  <li>특정 객체 안에 속성과 기능을 캡슐로 만들어 데이터를 외부로부터 보호하는 것</li>
  <li>데이터의 보호, 불필요한 노출을 방지하기 위해 캡슐화를 사용한다(정보은닉)</li>
</ul>

<h3 id="-접근-제어자"><font color="#A0D7EF"> 접근 제어자</font></h3>
<hr />

<table>
  <thead>
    <tr>
      <th>접근 제어자</th>
      <th>접근 제한 범위</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>private</td>
      <td>동일 클래스에서만 접근 가능</td>
    </tr>
    <tr>
      <td>default</td>
      <td>동일 패키지 내에서만 접근 가능</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>동일 패키지 + 다른 패키지의 하위 클래스에서 접근 가능</td>
    </tr>
    <tr>
      <td>public</td>
      <td>접근 제한 없음</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>접근 제어자는 단 하나만 선언 될 수 있다</li>
  <li><strong>public &gt; protected &gt; default &gt; private</strong> 순으로 정리된다</li>
  <li>접근 제어자를 작성하지 않았을 경우 default 접근 제어자가 할당된다</li>
</ul>

<h3 id="-getter와-setter-매소드"><font color="#A0D7EF"> getter와 setter 매소드</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setter</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getter</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <p>접근 지정자를 private로 설정해 놓으면 클래스 밖에서 변수나 매소드에 관여 할 수 없기 때문에
  Getter와 Setter 매소드를 이용하여 접근 할 수 있도록 한다</p>
</blockquote>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>오늘은 상속과 캡슐화 방법에 대해 배웠다.</p>

<p>상속은 프로젝트 할 때 자주 사용해 본 적이 없어서<br />
사실 이론으로만 알고 실습에서 사용 한 적은 별로 없었던 것 같다<br />
그래도 큰 프로젝트를 하게 되면 사용하게 되지 않을까 생각한다.<br /></p>

<p>캡슐화는 자주 사용했던 것 같다.<br />
그중에 getter와 setter는 영혼의 단짝이라고 볼 수 있다.</p>

<p>getter와 setter를 자동으로 완성시켜 주는 기능도 있었던 걸로 기억한다.</p>

<p>객체지향 프로그래밍을 공부하면서 알고리즘 분야도 중요하지만<br />
이런 개념과 틀을 세분화 시킬 수 있는 능력도 중요하다는 생각이든다.</p>

<p>빨리 프로젝트를 진행해보고 싶다,,,!!</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코드스테이츠 백엔드 10일차 회고록</title><link href="http://localhost:4000/memoir/SEB_BE10/" rel="alternate" type="text/html" title="코드스테이츠 백엔드 10일차 회고록" /><published>2023-04-24T00:00:00+09:00</published><updated>2023-04-24T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE10</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE10/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="1-생성자constructor"><font color="#A0D7EF">1. 생성자(Constructor)</font></h2>

<ul>
  <li>인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드</li>
  <li><code class="language-plaintext highlighter-rouge">new</code> 키워드를 통해 객체를 생성할 때 호출되는 메소드</li>
  <li>생성자 이름은 반드시 클래스의 이름과 같아야한다</li>
  <li>생성자는 리턴 타입이 없다</li>
  <li>메소드 오버로딩이 가능하다</li>
  <li>생성자를 작성하지 않으면 컴파일러에서 기본 생성자를 생성해준다</li>
  <li>this() 메소드를 통해 다른 오버로딩된 생성자를 불러올 수 있다
<br /></li>
</ul>

<h2 id="-2-내부-클래스inner-class"><font color="#A0D7EF"> 2. 내부 클래스(Inner Class)</font></h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Outer</span> <span class="o">{</span> <span class="c1">// 외부 클래스</span>
	<span class="kd">class</span> <span class="nc">Inner</span> <span class="o">{</span> <span class="c1">// 인스턴스 내부 클래스</span>

	<span class="o">}</span>

	<span class="kd">static</span> <span class="kd">class</span> <span class="nc">StaticInner</span> <span class="o">{</span>  <span class="c1">// 정적 내부 클래스</span>

	<span class="o">}</span>

	<span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="kd">class</span> <span class="nc">LocalInner</span> <span class="o">{</span> <span class="c1">// 지역 내부 클래스</span>

		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>클래스 내에 선언된 클래스</li>
  <li>클래스를 논리적으로 그룹화 할 수 있다</li>
  <li>캡슐화, 코드의 가독성에 도움이 된다</li>
</ul>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>선언위치</th>
      <th>사용 가능한 변수</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>인스턴스 내부 클래스(instance inner class)</td>
      <td>외부 클래스의 멤버변수 선언위치에 선언(멤버 내부 클래스)</td>
      <td>외부 인스턴스 변수, 외부 전역 변수</td>
    </tr>
    <tr>
      <td>정적 내부 클래스(static inner class)</td>
      <td>외부 클래스의 멤버변수 선언위치에 선언(멤버 내부 클래스)</td>
      <td>외부 전역 변수</td>
    </tr>
    <tr>
      <td>지역 내부 클래스(local inner class)</td>
      <td>외부 클래스의 메소드나 초기화 블록 안에 선언</td>
      <td>외부 인스턴스 변수, 외부 전역 변수</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h1 id="-실습-문제"><font color="#A0D7EF"> 실습 문제</font></h1>
<blockquote>
  <p>LoL_Program.java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoL_Program</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Charactor</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Charactor</span><span class="o">();</span>
        <span class="nc">Charactor</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Charactor</span><span class="o">();</span>

        <span class="n">a</span><span class="o">.</span><span class="na">user_create</span><span class="o">();</span>
        <span class="n">b</span><span class="o">.</span><span class="na">user_create</span><span class="o">();</span>

        <span class="nc">Charactor</span><span class="o">.</span><span class="na">attack</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<blockquote>
  <p>LoL_char.java</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Charactor</span> <span class="o">{</span>

    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">ad</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">def</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">hp</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">create_info</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] 생성된 유닛 정보는 다음과 같습니다."</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] "</span><span class="o">+</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">+</span><span class="s">" 유닛이 게임에 참여하였습니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">user_info</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[공격력] : "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">ad</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[방어력] : "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">def</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[체력] : "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">hp</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">user_create</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"[시스템] 유닛 [이름] 을 입력해 주세요 : "</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"[시스템] 유닛 [공격력] 을 입력해 주세요 : "</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ad</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"[시스템] 유닛 [방어력] 을 입력해 주세요 : "</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">def</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"[시스템] 유닛 [체력] 을 입력해 주세요 : "</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">hp</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

        <span class="n">create_info</span><span class="o">();</span>
        <span class="n">user_info</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">attack</span><span class="o">(</span><span class="nc">Charactor</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Charactor</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">b</span><span class="o">.</span><span class="na">hp</span> <span class="o">=</span> <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">hp</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="na">def</span><span class="o">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="na">ad</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] "</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="na">name</span><span class="o">+</span><span class="s">"유닛이 공격 하였습니다"</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">hp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] 상대 유닛("</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="na">name</span><span class="o">+</span><span class="s">")이 제거되었습니다."</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] 상대 유닛의 남은 [체력은] "</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="na">hp</span><span class="o">+</span><span class="s">" 입니다."</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="n">a</span><span class="o">.</span><span class="na">hp</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">hp</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">def</span><span class="o">)</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="na">ad</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] "</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="na">name</span><span class="o">+</span><span class="s">"유닛이 공격 하였습니다"</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">hp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내]"</span> <span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="na">name</span><span class="o">+</span><span class="s">"이(가) 파괴되었습니다."</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] 내 유닛의 남은 [체력은] "</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="na">hp</span><span class="o">+</span><span class="s">" 입니다."</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[안내] 게임을 종료합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>오늘은 생성자와 내부 클래스에 대해 배웠다.<br /></p>

<p>예전에 공부 할 때 내부 클래스 부분을 소홀히 공부했는지<br />
처음 보는 것 같기도 했고, 잘 이해가 안갔었다.<br /></p>

<p>가장 이해가 안됐던건 내부 클래스를 왜 사용하는가 였다.<br /></p>

<p>인터넷에 검색해보니까 내부 클래스를 사용하면<br />
클래스 파일을 하나 더 적게 생성 할 수 있고<br />
클래스의 연결 관계가 간결해져서 가독성이 좋아지고<br />
캡슐화를 더 단단하게 해줄 수 있다. 라고 나와있었다.<br /></p>

<p>정확한 실습을 하지 않아서 완전히 이해하진 않았지만<br />
어느 맥락에서 사용되는지 이해는 갔다.<br /></p>

<p>앞으로 코딩을 할 때 내부 클래스를 사용하는 방법을<br />
익혀야겠다고 생각했다. <br /></p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코드스테이츠 백엔드 9일차 회고록</title><link href="http://localhost:4000/memoir/SEB_BE9/" rel="alternate" type="text/html" title="코드스테이츠 백엔드 9일차 회고록" /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-21T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE9</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE9/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="1-클래스"><font color="#A0D7EF">1. 클래스</font></h2>
<ul>
  <li>객체를 정의한 설계도 또는 틀</li>
  <li>객체를 생성하는데 사용된다</li>
  <li>객체의 변수와 메소드의 집합이다</li>
</ul>

<h3 id="클래스의-구성-요소"><font color="#A0D7EF">클래스의 구성 요소</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span> <span class="c1">// 클래스 명</span>
	<span class="nc">Car</span><span class="o">(){..}</span> <span class="c1">// 생성자 </span>
	<span class="kt">int</span> <span class="n">name</span> <span class="o">=</span> <span class="err">“</span><span class="n">승용차</span><span class="err">”</span> <span class="c1">// 필드</span>
	<span class="kt">int</span> <span class="nf">getPrice</span><span class="o">(){..}</span> <span class="c1">// 매서드</span>
	<span class="kd">class</span> <span class="nc">innerClass</span> <span class="o">{..}</span> <span class="c1">// 이너 클래스</span>
<span class="o">}</span>

</code></pre></div></div>
<ul>
  <li>필드 - 클래스의 속성(state)을 나타내는 변수</li>
  <li>메서드 - 클래스의 기능(behavior)0을 나타내는 함수</li>
  <li>생성자 - 객체를 생성하는 역할을 하는 부분</li>
  <li>이너 클래스 - 클래스 내부의 클래스</li>
</ul>

<h2 id="-2-객체"><font color="#A0D7EF"> 2. 객체</font></h2>
<ul>
  <li>실세계에 존재하거나 생각할 수 있는 것을을 객체(Object)라고한다</li>
  <li>객체와 인스턴스는 비슷한 개념으로 쓰이나 객체가 더 큰 범위를 가진다</li>
</ul>

<h3 id="-객체의-생성"><font color="#A0D7EF"> 객체의 생성</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Car</span> <span class="n">bmw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">bmw</span><span class="o">()</span> <span class="c1">//Car 클래스를 통해 인스턴스를 생성 후, 참조변수에 저장</span>
</code></pre></div></div>
<ul>
  <li>new 생성자()를 통해 인스턴스를 참조변수에 넣어준다</li>
  <li>참조 변수는 인스턴스가 저장되어있는 힙 메모리의 주소값을 가리킨다</li>
  <li>인스턴스의 매서드는 클래스 영억의 매서드를 가리킨다</li>
</ul>

<h3 id="-객체의-활용"><font color="#A0D7EF"> 객체의 활용</font></h3>
<hr />

<ul>
  <li>객체는 포인트 연산자(.)를 통해 접근 가능하다</li>
  <li><code class="language-plaintext highlighter-rouge">bmw.name, bmw.getPrice()</code></li>
</ul>

<h2 id="-2-필드멤버-변수"><font color="#A0D7EF"> 2. 필드(멤버 변수)</font></h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="nc">Example</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">instanceVariable</span><span class="o">;</span> <span class="c1">// 인스턴스 변수, 객체마다 고유 값을 가진다</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="n">classVariable</span><span class="o">;</span> <span class="c1">// 클래스 변수, 같은 객체면 값을 공유한다</span>
	
	<span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">localVariable</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 지역 변수, 블록 안에서만 존재한다		</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>클래스 변수는 객체가 생성 될 때 생성된다</li>
  <li>지역 변수는 객체의 생성 없이 사용할 수 있다</li>
  <li>지역 메모리는 반드시 초기값을 가져야한다</li>
</ul>

<h2 id="-4-매소드method"><font color="#A0D7EF"> 4. 매소드(Method)</font></h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">제어자</span> <span class="o">|</span> <span class="n">반환</span> <span class="n">타입</span> <span class="o">|</span> <span class="n">메소드</span> <span class="n">명</span> <span class="o">|</span> <span class="n">매개</span> <span class="n">변수</span> <span class="n">타입</span><span class="o">,</span> <span class="n">이름</span> 
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">method</span><span class="o">(</span><span class="kt">int</span> <span class="n">exe</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// -&gt; 메소드 시그니처</span>
    <span class="c1">// 메소드 바디</span>
  <span class="o">}</span>

</code></pre></div></div>

<ul>
  <li>특정 작업을 수행하는 일련의 명령문들의 집합, 기능을 담담한다</li>
  <li>매소드 시그니처, 메소드 바디로 구분 할 수 있다.</li>
  <li>메소드 시그니처는 접근 지정자, 반환타입, 매소드명, 매개변수로 이루어져있다</li>
  <li>관례적으로 매소드명은 소문자로 선언된다</li>
  <li>메소드 바디는 메소드가 호출 됐을 때 수행되는 작업을 명시한다</li>
</ul>

<h3 id="-메소드-오버로딩method-overloding"><font color="#A0D7EF"> 메소드 오버로딩(Method Overloding)</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">method</span><span class="o">(</span><span class="kt">int</span> <span class="n">exe</span><span class="o">)</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">method</span><span class="o">(</span><span class="kt">int</span> <span class="n">exe</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">method</span><span class="o">(</span><span class="kt">int</span> <span class="n">exe</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{}</span>

</code></pre></div></div>

<ul>
  <li>클래스 안에 같은 이름의 메소드를 여러개 정의하는 것</li>
  <li>같은 이름, 매개변수 개수와 타입은 다르게 정의되어야 한다</li>
  <li>반환타입은 오버로딩 조건에 영향을 주지 못한다</li>
</ul>

<p><br /></p>
<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>오늘은 본격적인 자바 공부를 시작했다.<br /><br />
오랜만에 공부하니까 너무 반갑기도 했고, 주말에 따로<br />
책을 보면서 다시 공부해봐야겠다 생각이 들었다.<br /><br />
다시 공부하는거니까 이번에는 심도있게 공부해야겠다 생각했다.<br /><br />
진짜 처음 공부할 때는 무슨 소리인지 하나도 이해 안가서<br />
실습만 4시간씩 하고 그랬었는데,,,, 추억이 생각난다.<br /><br />
열심히 공부해서 기초 탄탄히 잡고 가자!!</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코드스테이츠 백엔드 8일차 회고록</title><link href="http://localhost:4000/memoir/SEB_BE8/" rel="alternate" type="text/html" title="코드스테이츠 백엔드 8일차 회고록" /><published>2023-04-20T00:00:00+09:00</published><updated>2023-04-20T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE8</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE8/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="1-배열"><font color="#A0D7EF">1. 배열</font></h2>
<ul>
  <li>같은 타입의 변수들로 이루어진 유한 집합</li>
  <li>배열은 배열의 요소(element)와 위치를 가리키는 숫자(index)로 이루어져 있다</li>
  <li>배열에 값을 저장하면 메모리 공간 상 물리적 값들이 모여있다</li>
</ul>

<h3 id="1차원-배열"><font color="#A0D7EF">1차원 배열</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span> <span class="c1">// 배열의 크기가 10인 1차원 배열 arr   </span>
</code></pre></div></div>
<ul>
  <li>배열의 타입과 길이는 변경 가능하다</li>
  <li>arr은 배열의 맨 첫번째 요소의 주소값을 가리킨다</li>
  <li><span style="color:#FFFF80"><code class="language-plaintext highlighter-rouge">arr[0], arr[2] ..</code></span>으로 값에 접근한다</li>
  <li><span style="color:#FFFF80"><code class="language-plaintext highlighter-rouge">arr.length</code></span> 매소드로 배열의 길이를 받을 수 있다</li>
</ul>

<h3 id="2차원-배열"><font color="#A0D7EF">2차원 배열</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]</span>
</code></pre></div></div>
<ul>
  <li>2차원 배열은 1차원 배열 두개가 중첩 된 것이다.</li>
  <li>가변배열로 사용가능하다(마지막 차수 길이 선언 생략 가능)</li>
  <li>그래프 알고리즘을 풀 때 많이 사용된다</li>
</ul>

<h3 id="-배열-탐색-방법"><font color="#A0D7EF"> 배열 탐색 방법</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>for문을 이용한 배열 탐색</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span><span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">++])</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>while문을 이용한 배열 탐색</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">element</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>for-Each문을 이용한 배열 탐색</li>
  <li>값을 불러오기만 할 뿐 수정할 수 없다</li>
  <li>while문은 조건식이 true일 경우 무한히 반복한다</li>
  <li>정해진 횟수가 없을 때 사용하기 좋다</li>
  <li>while문을 탈출하기 위한 코드를 꼭 작성해야한다</li>
</ul>

<p><br /></p>

<h1 id="-응용-문제"><font color="#A0D7EF"> 응용 문제</font></h1>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">fibonacci_Function</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">bf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">41</span><span class="o">];</span>

        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">41</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]+</span><span class="s">" "</span><span class="o">+</span><span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="k">else</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="s">" "</span><span class="o">+</span><span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">]);</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>다이나믹 프로그래밍 알고리즘 <a href="https://www.acmicpc.net/problem/1003">백준_피보나치 함수</a><br />
오늘 풀었던 피보나치 함수 문제의 연장선상이다
<br /><br /></p>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>오늘은 배열에 대해 배워보았다!!<br /><br />
자료구조 알고리즘을 공부 할 때는 배열보다 다른 자료구조를<br />
많이 사용했어서 오늘 여러 함수 없이 문제를 진행하는데 조금 어려움이 있었다<br /><br />
여러 개발자들이 미리 만들어 놓은 함수에 압도적인 감사를,,,,!!!<br /><br />
오늘을 마지막으로 자바의 기초문법은 끝나게 되었다<br />
내일부터 객체지향 프로그래밍을 배우는데 자바에서 손 뗀지 오래돼서<br />
사실 잘 기억이 안난다,,,,,ㅋㅌㅋㅋㅋㅋㅋ<br /><br />
새내기 시절 때 머리 엄청 싸메여가며 고통받았던 것 같은데<br />
통달했을 때는 이것저것 만드는 재미가 있었던 것으로 기억한다!!<br /><br />
다시 배우는 입장이니까 빠르게 이해 할 수 있지 않을까 생각한다!!<br />
블로깅 챌린지가 얼마 남지 않았다!! 좀만 더 고생하자!</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">코드스테이츠 백엔드 7일차 회고록</title><link href="http://localhost:4000/memoir/SEB_BE7/" rel="alternate" type="text/html" title="코드스테이츠 백엔드 7일차 회고록" /><published>2023-04-19T00:00:00+09:00</published><updated>2023-04-19T00:00:00+09:00</updated><id>http://localhost:4000/memoir/SEB_BE7</id><content type="html" xml:base="http://localhost:4000/memoir/SEB_BE7/"><![CDATA[<style> 
    p { line-height : 1.75em; }
</style>

<h1 id="-배운점"><font color="#A0D7EF"> 배운점</font></h1>

<h2 id="1-반복문"><font color="#A0D7EF">1. 반복문</font></h2>
<blockquote>
  <p>코드들이 반복적으로 실행되도록 할 때 사용된다</p>
</blockquote>

<h3 id="for문"><font color="#A0D7EF">for문</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">for</span><span class="o">(</span><span class="cm">/*초기화; 조건식; 증감식*/</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 반복 실행될 구문</span>

    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>for문은 조건식이 참인 동안 주어진 횟수만큼 실행문을 수행한다(수행횟수를 알 때)</li>
  <li>초기화는 for문이 시작 할 때 최초 한번만 수행된다</li>
  <li>조건식 안의 값이 true면 실행하고 false면 반복문을 종료한다</li>
  <li>증감식은 반복 횟수를 결정한다<br /></li>
</ul>

<h3 id="향상된-for문enhanced-for문"><font color="#A0D7EF">향상된 for문(Enhanced for문)</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">num</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">};</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">elements</span> <span class="o">:</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elements</span><span class="o">);</span>

    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>컬랙션 객체를 처리할 목적으로는 향상된 for문을 사용한다</li>
  <li>위 코드는 num안에 있는 요소들을 출력하는 코드이다</li>
</ul>

<h3 id="while문"><font color="#A0D7EF">while문</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="k">while</span><span class="o">(</span><span class="n">조건식</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 조건이 참일 경우 실행될 구문</span>
      <span class="n">cnt</span><span class="o">++</span> <span class="c1">// 증감식</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>while문은 조건식이 true일 경우 무한히 반복한다</li>
  <li>정해진 횟수가 없을 때 사용하기 좋다</li>
  <li>while문을 탈출하기 위한 코드를 꼭 작성해야한다</li>
</ul>

<h3 id="-break문과-continue문"><font color="#A0D7EF"> break문과 continue문</font></h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span><span class="o">(</span><span class="cm">/*초기화; 조건식; 증감식*/</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="cm">/*조건식*/</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
      <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="cm">/*조건식*/</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
      <span class="c1">// 반복 실행될 구문</span>

    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>break문은 가까운 반복문을 탈출할 때 사용한다</li>
  <li>continue문은 다음 반복으로 넘어갈 때 사용한다</li>
</ul>

<p><br /></p>

<h1 id="-응용-문제"><font color="#A0D7EF"> 응용 문제</font></h1>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">recurrenceRelation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">bf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">bf</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="mi">36</span><span class="o">];</span>

        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">*</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>다이나믹 프로그래밍 알고리즘 문제 <a href="https://www.acmicpc.net/problem/13699">백준_점화식</a>
<br /><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">pascal_Triangle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">square</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">square</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">square</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">square</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">square</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">square</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">square</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>다이나믹 프로그래밍 알고리즘 <a href="https://www.acmicpc.net/problem/16395">백준_파스칼의 삼각형</a><br />
이와 같이 반복문은 자주 쓰이는 문법이다
<br /><br /></p>

<h1 id="-느낀점"><font color="#A0D7EF"> 느낀점</font></h1>
<hr />

<p>오늘은 이론 공부보다는 실습 공부를 더 많이 한 것 같다.<br /><br />
다른 메소드의 사용 없이 순수 for문 만으로 문제를 푸는건 오랜만이라서<br />
생각보다 문제를 푸는데 시간이 걸렸던 것 같다.<br /><br />
그래도 코틀린 문제를 풀 때는 다음에 어떤 문제가 나올지 기대되서<br />
푸는 재미가 있는 것 같다!!<br /><br />
오늘 복습하는 시간보다 알고리즘 문제를 푸는데 시간이 더 많이 쓰인 것 같지만<br />
이것 또한 반복문을 숙달하기 위한 과정이라고,,, 생,, 생각한다!!!<br /><br />
매일 백준 2문제, 공부, TIL 블로그 작성 등 생각보다 할 일이 많다,,,<br />
나중에 프로젝트 시작하면 몸이 남아나질 않을 것 같은 느낌이,,,,!!<br /><br />
그래도 날 부러트리지 못하는 시련은 날 더 강하게 만들 뿐이다!!</p>]]></content><author><name>양재용</name><email>yjy850146@gmail.com</email></author><category term="Memoir" /><category term="Codestates" /><summary type="html"><![CDATA[]]></summary></entry></feed>