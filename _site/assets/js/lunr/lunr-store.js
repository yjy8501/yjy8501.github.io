var store = [{
        "title": "블로그 첫 포스팅 글",
        "excerpt":"[위험] 작심삼일이 될 수 있는 블로그입니다. 안녕하세요. 이번에 부트캠프 훈련을 앞두고 이것저것 기록용으로 사용하려고 깃 블로그 만들어봤습니다!! 개발 공부 관련된 내용 올릴 예정이고, 실력이 부족해서 제 글이 누군가에게 도움이 될 수 있을거란 생각은 하지 않아요,,,ㅠㅜ 제가 공부했던 부분들 다시 리와인드 할 목적으로 사용 할 것 같아요!! 그래도 꾸준히 공부하고, 포스팅하다...","categories": ["Life"],
        "tags": ["Blog"],
        "url": "/life/first/",
        "teaser": null
      },{
        "title": "파이썬 백준 10812번 문제 풀이",
        "excerpt":"1. 문제 분석 이 문제를 처음 읽었을 때는 큐로 문제를 풀어나가야 하나 생각을 했다. 문제를 차분하게 살펴보니 큐를 사용하지 않고 간단하게 리스트 슬라이싱을 이용하면 풀 수 있다는 생각이 들어 리스트 슬라이싱 방법으로 문제에 접근했다. begin, end, middle 이런식으로 i, j, k를 입력 받는다면 1. begin에서 middle - 1까지의 배열을 복사해서...","categories": ["BaekJoon"],
        "tags": ["Coding","Python"],
        "url": "/baekjoon/second/",
        "teaser": null
      },{
        "title": "파이썬 백준 2903번 문제 풀이",
        "excerpt":"1. 문제 분석 한 변의 길이는 1, 2, 4, 8 이런식으로 2의 배수 만큼 길어진다. 한 변에 있는 원의 개수는 한 변의 길이 + 1 이다. 따라서 전체 원의 개수는 한 변에 있는 원의 개수 * 2 2. 코드 import math N = int(input()) # N을 입력받는다 side = int(math.pow(2,...","categories": ["BaekJoon"],
        "tags": ["Coding","Python"],
        "url": "/baekjoon/baekJoon_2903/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 1일차 회고록",
        "excerpt":"배운점 1. 메타인지란 무엇인가? 메타인지란 현재 나의 인지 상태를 모니터링하는 능력이다. 내 방식대로 이해하자면 내가 무엇을 알고, 무엇을 모르는지 정확히 판단 할 수 있는 것이 메타인지 능력인 것 같다. 어중간하게 아는 것이 제일 무서운 것이다. 라고 스스로 생각하기도 하고, 전공생인 입장으로써 이미 배운 영역이 많이 나올테지만 자만하지 않고 처음부터 다시...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE1/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 2일차 회고록",
        "excerpt":"배운점 1. 컴퓨터와 프로그래밍이란? 우리는 컴퓨터를 흔히 만능 머신이라고 생각한다. 하지만 우리가 사용하는 많은 기능들은 프로그래머들이 컴퓨터가 이해할 수 있게 프로그래밍 언어를 사용하여 컴퓨터가 해야 할 행동들을 설정해놓은 것들이다. 그렇기 때문에 컴퓨터 입장에서 생각하며 프로그래밍을 하는 연습을 해야한다. 2. 웹 서버와 클라이언트 간단하게 말하자면 클라이언트는 리소스를 사용하는 곳, 서버는 리소스를...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE2/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 3일차 회고록",
        "excerpt":"배운점 1. CLI (Command Line Interface) CLI (Command Line Interface) GUI보다 빠르고, 높은 안정성을 가짐 서버 컴퓨터에 접근할 때 사용됨 GUI보다 컴퓨터 자원을 덜 차지한다 GUI(Graphic User Interface) PC(Personal Computer)에 사용되기에 유저에 친숙하고 편하다. 여러개의 I/O장치를 통해 입출력 받을 수 있다. 백엔드 개발자는 서버를 다루기도 하기 때문에 CLI에서 개발하는 환경에...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE3/",
        "teaser": null
      },{
        "title": "파이썬 백준 11478번 문제 풀이",
        "excerpt":"1. 문제 분석 집합에는 중복값을 넣을 수 없다 부분 문자열의 값을 집합에 넣어준다. 슬라이싱을 이용하여 부분 문자열을 만든다 ababc, abab, aba, ab, a babc, bab, ba, b abc, ab, a bc, b c [0:5] [0:4] [0:3] [0:2] [0:1] [1:5] [1:4] [1:3] [1:2] [2:5] [2:4] [2:3] [3:5] [3:4] [4:5] 2. 코드...","categories": ["BaekJoon"],
        "tags": ["Coding","Python"],
        "url": "/baekjoon/baekJoon_11478/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 4일차 회고록",
        "excerpt":"배운점 1. Git Git 리누스 토르발스가 만든 버전 관리 시스템(VSC) 파일의 변경 사항을 추적하며, 각 파일의 버전을 관리할 수 있게 도와준다 협업자들과 함께 파일을 공유하고, 취합 할 수 있게 도와준다 GitHub Git을 사용하는 프로젝트를 지원하는 웹 호스팅 서비스 Workflow Working Directory 현재 작업하고 있는 파일이 저장되어 있는 곳 Staging Area...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE4/",
        "teaser": null
      },{
        "title": "파이썬 백준 18870번 문제 풀이",
        "excerpt":"1. 문제 분석 중복값 없이 좌표를 정렬한다. Set에 넣은 다음 Sorted 함수를 통해 정렬된 리스트를 받는다 정렬 된 모습 sorted X -10 -9 4 2 X’ 0 1 2 3 sorted X와 X’를 연결 해야한다. sorted X를 Key, X’를 Value로 넣은 딕셔너리를 만든다 2. 코드 import copy import sys compressed_X...","categories": ["BaekJoon"],
        "tags": ["Coding","Python","Sort"],
        "url": "/baekjoon/baekJoon_18870/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 5일차 회고록",
        "excerpt":"배운점 1. Java Java JVM(Java Virtual Machine)을 이용하여 운영체제에 독립적이다. 객체지향언어(Object Oriented Programming, OOP), 유지보수가 쉽고 확장성이 높다. 함수형프로그래밍 지원, 람다식 스트림을 지원한다. 자동 메모리 관리(Garbage Collection)을 통해 사용되지 않는 메모리를 수거한다. 2. JVM(Java Virtual Machine) JVM 자바 프로그램의 실행환경을 만들어주는 소프트웨어. 컴파일러는 자바 언어를 JVM이 이해할 수 있는 바이트...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE5/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 6일차 회고록",
        "excerpt":"배운점 1. 연산자(Operator) 하나의 값 또는 여려 개의 값을 피연산자로 하여 새로운 값을 만들어내는 기호 산술 연산자 덧셈 연산자(+) 두 항의 값을 더한 값을 반환한다 뺄셈 연산자(-) 좌항의 값에서 우항의 값을 뺀 값을 반환한다 곱셈 연산자(*) 두 항의 값을 곱한 값을 반환한다 나눗셈 연산자(/) 좌항을 우항으로 나눈 값을 반환한다 나머지...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE6/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 7일차 회고록",
        "excerpt":"배운점 1. 반복문 코드들이 반복적으로 실행되도록 할 때 사용된다 for문 public class Main { public static void main(String[] args) { for(/*초기화; 조건식; 증감식*/) { // 반복 실행될 구문 } } } for문은 조건식이 참인 동안 주어진 횟수만큼 실행문을 수행한다(수행횟수를 알 때) 초기화는 for문이 시작 할 때 최초 한번만 수행된다 조건식...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE7/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 8일차 회고록",
        "excerpt":"배운점 1. 배열 같은 타입의 변수들로 이루어진 유한 집합 배열은 배열의 요소(element)와 위치를 가리키는 숫자(index)로 이루어져 있다 배열에 값을 저장하면 메모리 공간 상 물리적 값들이 모여있다 1차원 배열 int[] arr = new int[10]; // 배열의 크기가 10인 1차원 배열 arr 배열의 타입과 길이는 변경 가능하다 arr은 배열의 맨 첫번째 요소의...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE8/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 9일차 회고록",
        "excerpt":"배운점 1. 클래스 객체를 정의한 설계도 또는 틀 객체를 생성하는데 사용된다 객체의 변수와 메소드의 집합이다 클래스의 구성 요소 Public class Car { // 클래스 명 Car(){..} // 생성자 int name = “승용차” // 필드 int getPrice(){..} // 매서드 class innerClass {..} // 이너 클래스 } 필드 - 클래스의 속성(state)을 나타내는...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE9/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 10일차 회고록",
        "excerpt":"배운점 1. 생성자(Constructor) 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드 new 키워드를 통해 객체를 생성할 때 호출되는 메소드 생성자 이름은 반드시 클래스의 이름과 같아야한다 생성자는 리턴 타입이 없다 메소드 오버로딩이 가능하다 생성자를 작성하지 않으면 컴파일러에서 기본 생성자를 생성해준다 this() 메소드를 통해 다른 오버로딩된 생성자를 불러올 수 있다 2. 내부 클래스(Inner...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE10/",
        "teaser": null
      },{
        "title": "코드스테이츠 백엔드 11일차 회고록",
        "excerpt":"배운점 1. 상속(Extends) 상위 클래스의 기능을 그대로 이어받아 재사용하는 것 코드의 재사용성을 높이고, 중복을 제거하여 생산성과 유지보수를 높힌다 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다 상속 구조가 복잡해지면 오히려 보수하기 힘들어 질 수 있다 클래스 간의 관계는 ‘~은 ~이다’(상속관계) ‘~은 ~을 가지고 있다’(포함관계)로 확인 할 수 있다. 매소드...","categories": ["Memoir"],
        "tags": ["Codestates"],
        "url": "/memoir/SEB_BE11/",
        "teaser": null
      }]
